import React, { useEffect, useReducer } from "react";
import { 
    Button,
    DialogActions,
    DialogContent,
    Grid,
} from "@material-ui/core";
import { blue } from "@material-ui/core/colors";
import PropTypes from "prop-types";

import reducerMalwareAnalysisSTIXObjects from "../reducer_handlers/reducerMalwareAnalysisSTIXObject.js";
import CreateMalwareAnalysisPatternElements from "../type_elements_stix/malwareAnalysisPatternElements.jsx";
import CreateListPreviousStateSTIX from "../createListPreviousStateSTIX.jsx";
import CreateElementAdditionalTechnicalInformationDO from "../createElementAdditionalTechnicalInformationDO.jsx";

const listFieldSTIXObjectRefs = {
    "email-message": "updateRefObjEmailMessageRef",    
    "network-traffic": "updateRefObjNetworkTrafficRef",
    "file": "updateRefObjFileRef",
    "domain-name": "updateResolvesToRefs",
    "directory": "addRefObj",
    "windows-registry-key": "updateCreatorUserRef",
};

function isExistTransmittedData(data){
    if((data.information === null) || (typeof data.information === "undefined")){
        return false;
    }

    if((data.information.additional_parameters === null) || (typeof data.information.additional_parameters === "undefined")){
        return false;
    }

    if((data.information.additional_parameters.transmitted_data === null) || (typeof data.information.additional_parameters.transmitted_data === "undefined")){
        return false;
    }

    if(data.information.additional_parameters.transmitted_data.length === 0){
        return false;
    }

    return true;
}

function reducerShowRef(state, action){
    switch(action.type){
    case "addObject":
        return {...state, obj: action.data};
    case "addId":
        return {...state, id: action.data};
    case "cleanObj":
        return {...state, obj: {}};
    }
}

export default function CreateDialogContentMalwareAnalysisSTIXObject(props){
    let { 
        socketIo,
        isNotDisabled,
        parentIdSTIXObject,
        currentAdditionalIdSTIXObject,
        handlerDialogClose,
    } = props;
    
    let [ buttonIsDisabled, setButtonIsDisabled ] = React.useState(true);
    let [ buttonSaveChangeTrigger, setButtonSaveChangeTrigger ] = React.useState(false);
    
    const handlerButtonIsDisabled = () => {
            if(!buttonIsDisabled){
                return;
            }
    
            setButtonIsDisabled();
        },
        handlerButtonSaveChangeTrigger = () => {
            setButtonSaveChangeTrigger((prevState) => !prevState);
        };
    
    return (<React.Fragment>
        <DialogContent>
            <Grid container direction="row" spacing={3}>
                <CreateMajorContent 
                    socketIo={socketIo}
                    parentIdSTIXObject={parentIdSTIXObject}
                    currentIdSTIXObject={currentAdditionalIdSTIXObject}
                    buttonSaveChangeTrigger={buttonSaveChangeTrigger}
                    isNotDisabled={isNotDisabled}
                    handlerDialogClose={handlerDialogClose}
                    handlerButtonIsDisabled={handlerButtonIsDisabled}
                    handlerButtonSaveChangeTrigger={handlerButtonSaveChangeTrigger}
                />
    
                <Grid item container md={4} style={{ display: "block" }}>
                    <CreateListPreviousStateSTIX 
                        socketIo={socketIo} 
                        searchObjectId={currentAdditionalIdSTIXObject} 
                    />
                </Grid>
            </Grid>            
        </DialogContent>
        <DialogActions>
            <Button 
                onClick={handlerDialogClose} 
                style={{ color: blue[500] }}
                color="primary">закрыть</Button>            
            {isNotDisabled && <Button
                disabled={buttonIsDisabled} 
                onClick={() => setButtonSaveChangeTrigger(true)}
                style={{ color: blue[500] }}
                color="primary">
                    сохранить
            </Button>}
        </DialogActions>
    </React.Fragment>);
}
    
CreateDialogContentMalwareAnalysisSTIXObject.propTypes = {
    socketIo: PropTypes.object.isRequired,
    isNotDisabled: PropTypes.bool.isRequired,
    parentIdSTIXObject: PropTypes.string.isRequired,
    currentAdditionalIdSTIXObject: PropTypes.string.isRequired,
    handlerDialogClose: PropTypes.func.isRequired,
};
    
function CreateMajorContent(props){
    let {
        socketIo,
        parentIdSTIXObject,
        currentIdSTIXObject,
        buttonSaveChangeTrigger,
        isNotDisabled,
        handlerDialogClose,
        handlerButtonIsDisabled,
        handlerButtonSaveChangeTrigger,
    } = props;
    
    //const [ state, dispatch ] = useReducer(reducerMalwareAnalysisSTIXObjects, {});    
    const [ stateShowRef, dispatchShowRef ] = useReducer(reducerShowRef, {id: "", obj: {}});
    const [ state, dispatch ] = useReducer(reducerMalwareAnalysisSTIXObjects, { mainObj: {}, refObj: {}, refId: "" });
    
    console.log("func 'CreateDialogContentMalwareAnalysisSTIXObject', state = ", state);
    
    useEffect(() => {
        socketIo.once("isems-mrsi response ui: send search request, get STIX object for id", (data) => {
            if(!isExistTransmittedData(data)){
                return;
            }

            for(let obj of data.information.additional_parameters.transmitted_data){     
                dispatch({ type: "newAll", data: obj });
            }
        });

        if(currentIdSTIXObject !== ""){
            socketIo.emit("isems-mrsi ui request: send search request, get STIX object for id", { arguments: { 
                searchObjectId: currentIdSTIXObject,
                parentObjectId: parentIdSTIXObject,
            }});
        }

        return () => {
            dispatch({ type: "newAll", data: {} });
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [ currentIdSTIXObject, parentIdSTIXObject ]);
    useEffect(() => {    
        if(buttonSaveChangeTrigger){
            socketIo.emit("isems-mrsi ui request: insert STIX object", { arguments: [ state.mainObj ] });
            
            handlerButtonSaveChangeTrigger();
            handlerDialogClose();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [ buttonSaveChangeTrigger ]);
    
    const updateRefObj = (parentId, data) => {
        console.log("func 'updateRefObj', parentId = ", parentId, " data = ", data);

        for(let value in listFieldSTIXObjectRefs){
            if(parentId.includes(value)){
                dispatch({ type: listFieldSTIXObjectRefs[value], data: data });
            }
        }
    };

    const handlerDialogElementAdditionalThechnicalInfo = (obj) => {
        if(obj.modalType === "external_references"){
            switch(obj.actionType){
            case "hashes_update":
                dispatch({ type: "updateExternalReferencesHashesUpdate", data: { newHash: obj.data, orderNumber: obj.orderNumber }});
                handlerButtonIsDisabled();
    
                break;
            case "hashes_delete":
                dispatch({ type: "updateExternalReferencesHashesDelete", data: { hashName: obj.hashName, orderNumber: obj.orderNumber }});
                handlerButtonIsDisabled();
    
                break;
            default:
                dispatch({ type: "updateExternalReferences", data: obj.data });
                handlerButtonIsDisabled();
            }
        }
        
        if(obj.modalType === "granular_markings") {
            dispatch({ type: "updateGranularMarkings", data: obj.data });
            handlerButtonIsDisabled();
        }
        
        if(obj.modalType === "extensions") {
            dispatch({ type: "updateExtensions", data: obj.data });
            handlerButtonIsDisabled();
        }
    };
    
    return (<Grid item container md={8} style={{ display: "block" }}>
        <Grid container direction="row" className="pt-3 pb-3">
            <CreateMalwareAnalysisPatternElements 
                isDisabled={false}
                showRefElement={stateShowRef}
                campaignPatterElement={state.mainObj}
                handlerClick={(parentId, refId) => {
                    socketIo.once("isems-mrsi response ui: send search request, get STIX object for id", (data) => {
                        if(!isExistTransmittedData(data)){
                            return;
                        }

                        for(let obj of data.information.additional_parameters.transmitted_data){
                            updateRefObj(parentId, obj);                           
                        }
                    });

                    socketIo.emit("isems-mrsi ui request: send search request, get STIX object for id", { arguments: { 
                        searchObjectId: refId,
                        parentObjectId: parentId,
                    }});
                }}
                handlerResult={(e) => { dispatch({ type: "updateResult", data: e.target.value }); handlerButtonIsDisabled(e.target.value); }}
                handlerProduct={(e) => { dispatch({ type: "updateProduct", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerVersion={(e) => { dispatch({ type: "updateVersion", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerSubmitted={(e) => { dispatch({ type: "updateSubmitted", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerResultName={(e) => { dispatch({ type: "updateResultName", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerListModules={(e) => { dispatch({ type: "updateListModules", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerAnalysisEnded={(e) => { dispatch({ type: "updateAnalysisEnded", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerButtonShowLink={(refId) => {
                    dispatchShowRef({ type: "addId", data: refId });
                    dispatchShowRef({ type: "cleanObj", data: {} });
            
                    socketIo.once("isems-mrsi response ui: send search request, get STIX object for id", (data) => {
                        if(!isExistTransmittedData(data)){
                            return;
                        }

                        for(let obj of data.information.additional_parameters.transmitted_data){ 
                            dispatchShowRef({ type: "addObject", data: obj });        
                        }
                    });

                    socketIo.emit("isems-mrsi ui request: send search request, get STIX object for id", { arguments: { 
                        searchObjectId: refId,
                        parentObjectId: state.id,
                    }});
                }}
                handlerAnalysisStarted={(e) => { dispatch({ type: "updateAnalysisStarted", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerConfigurationVersion={(e) => { dispatch({ type: "updateConfigurationVersion", data: e.target.value }); handlerButtonIsDisabled(); }}
                handleranAlysisEngineVersion={(e) => { dispatch({ type: "updateAlysisEngineVersion", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerAnalysisDefinitionVersion={(e) => { dispatch({ type: "updateAnalysisDefinitionVersion", data: e.target.value }); handlerButtonIsDisabled(); }}
            />

            {/*<CreateMalwarePatternElements 
                isDisabled={false}
                showRefElement={stateShowRef}
                campaignPatterElement={state}
                handlerName={(e) => { dispatch({ type: "updateName", data: e.target.value }); handlerButtonIsDisabled(e.target.value); }}
                handlerAliases={(e) => { dispatch({ type: "updateAliases", data: e }); handlerButtonIsDisabled(); }}
                // Aliases - альтернативные имена используемые для этого субъекта угроз
                handlerIsFamily={(e) => { dispatch({ type: "updateIsFamily", data: e.target.value }); handlerButtonIsDisabled(e.target.value); }}
                // IsFamily - представляет ли объект семейство вредоносных программ (если true) или экземпляр вредоносного ПО (если false) (ОБЯЗАТЕЛЬНОЕ ЗНАЧЕНИЕ)
                handlerLastSeen={(e) => { dispatch({ type: "updateLastSeenTime", data: e }); handlerButtonIsDisabled(); }}
                // LastSeen - время, в формате "2016-05-12T08:17:27.000Z", когда данный субъект угроз был зафиксирован в последний раз
                handlerFirstSeen={(e) => { dispatch({ type: "updateFirstSeenTime", data: e }); handlerButtonIsDisabled(); }}
                // FirstSeen - время, в формате "2016-05-12T08:17:27.000Z", когда данный субъект угроз был впервые зафиксирован
                //handlerSampleRefs={(e) => { dispatch({ type: "updateSampleRefs", data: e }); handlerButtonIsDisabled(); }}        
                // SampleRefs - определяет список идентификаторов файлов или артифактов ассоциируемых с вредоносным ПО или семейством вредоносных программ.
                //  По факту данное поле может содержать только SCO объекты file, artifact.
                handlerDescription={(e) => { dispatch({ type: "updateDescription", data: e.target.value }); handlerButtonIsDisabled(); }}
                handlerCapabilities={(e) => { dispatch({ type: "updateCapabilities", data: e.target.value }); handlerButtonIsDisabled(); }}
                // Capabilities - заранее определенный (предложенный) перечень возможных идентификаторов используемых для обнаружения вредоносного ПО или семейства вредоносных программ
                handlerMalwareTypes={(e) => { dispatch({ type: "updateMalwareTypes", data: e.target.value }); handlerButtonIsDisabled(e.target.value); }}
                // MalwareTypes - заранее определенный (предложенный) перечень вредоносного ПО 
                handlerButtonShowLink={(refId) => {
                    dispatchShowRef({ type: "addId", data: refId });
                    dispatchShowRef({ type: "cleanObj", data: {} });
            
                    socketIo.once("isems-mrsi response ui: send search request, get STIX object for id", (data) => {
                        if(!isExistTransmittedData(data)){
                            return;
                        }

                        for(let obj of data.information.additional_parameters.transmitted_data){ 
                            dispatchShowRef({ type: "addObject", data: obj });        
                        }
                    });

                    socketIo.emit("isems-mrsi ui request: send search request, get STIX object for id", { arguments: { 
                        searchObjectId: refId,
                        parentObjectId: state.id,
                    }});
                }}
                handlerDeleteKillChain={(e) => { dispatch({ type: "deleteKillChainPhases", data: e }); handlerButtonIsDisabled(); }}
                handlerAddKillChainPhases={(e) => { dispatch({ type: "updateAddKillChainPhases", data: e }); handlerButtonIsDisabled(); }}
                // KillChainPhases - список цепочки фактов, к которым может быть отнесено это вредоносное ПО
                //handlerOperatingSystemRefs={(e) => { dispatch({ type: "OperatingSystemRefs", data: e }); handlerButtonIsDisabled(); }}
                // OperatingSystemRefs - перечень идентификаторов ОС в которых может быть выполнено вредоносное ПО или семейство вредоносных программ
                handlerImplementationLanguages={(e) => { dispatch({ type: "updateImplementationLanguages", data: e.target.value }); handlerButtonIsDisabled(); }}
                // ImplementationLanguages - заранее определенный (предложенный) перечень языков программирования, используемых для реализации вредоносного ПО или семейства вредоносных программ
                handlerArchitectureExecutionEnvs={(e) => { dispatch({ type: "updateArchitectureExecutionEnvs", data: e.target.value }); handlerButtonIsDisabled(); }}
                // ArchitectureExecutionEnvs - заранее определенный (предложенный) перечень архитектур в которых может быть выполнено вредоносное ПО или семейство вредоносных программ
            />*/}
        </Grid> 
    
        <CreateElementAdditionalTechnicalInformationDO
            objectId={currentIdSTIXObject}
            reportInfo={state.mainObj}
            isNotDisabled={isNotDisabled}
            handlerElementConfidence={(e) => { dispatch({ type: "updateConfidence", data: e }); handlerButtonIsDisabled(); }}
            handlerElementDefanged={(e) => { dispatch({ type: "updateDefanged", data: e }); handlerButtonIsDisabled(); }}
            handlerElementLabels={(e) => { dispatch({ type: "updateLabels", data: e }); handlerButtonIsDisabled(); }}
            handlerElementDelete={(e) => { dispatch({ type: "deleteElementAdditionalTechnicalInformation", data: e }); handlerButtonIsDisabled(); }}
            handlerDialogElementAdditionalThechnicalInfo={handlerDialogElementAdditionalThechnicalInfo} 
        />
    </Grid>);
}
    
CreateMajorContent.propTypes = {
    socketIo: PropTypes.object.isRequired,
    parentIdSTIXObject: PropTypes.string.isRequired,
    currentIdSTIXObject: PropTypes.string.isRequired,
    buttonSaveChangeTrigger: PropTypes.bool.isRequired,
    isNotDisabled: PropTypes.bool.isRequired,
    handlerDialogClose: PropTypes.func.isRequired,
    handlerButtonIsDisabled: PropTypes.func.isRequired,
    handlerButtonSaveChangeTrigger: PropTypes.func.isRequired,
};

/**
//MalwareAnalysisDomainObjectsSTIX объект "Malware Analysis", по терминалогии STIX, содержит анализ вредоносных программ захватывающих метаданные
//  и результаты конкретного статического или динамического анализа, выполненного на экземпляре вредоносного ПО или семействе вредоносных программ
// Product - название аналитического ПО использованного для обработки и анализа вредоносного ПО (ОБЯЗАТЕЛЬНОЕ ЗНАЧЕНИЕ)
// Version - версия аналитического ПО
// HostVMRef - идентификатор на описание виртуального окружения использованного для анализа вредоносного ПО
// OperatingSystemRef - идентификатор на описание ОС используемой для динамического анализа вредоносного ПО
// InstalledSoftwareRefs - список идентификаторов ссылающихся на описание любого нестандартного ПО установленного в ОС используемой для динамического
//  анализа вредоносного ПО
// ConfigurationVersion - именованная конфигурация дополнительных параметров конфигурации продукта, используемого для анализа
// Modules - конкретные модули анализа, которые были использованы и сконфигурированы в продукте во время выполнения анализа
// AnalysisEngineVersion - версия аналитического движка или продукта (включая AV-движки), который был использован для выполнения анализа
// AnalysisDefinitionVersion - версия определений анализа, используемых инструментом анализа (включая AV-инструменты)
// Submitted - время, в формате "2016-05-12T08:17:27.000Z", когда вредоносное ПО было впервые отправлено на сканирование или анализ
// AnalysisStarted - время, в формате "2016-05-12T08:17:27.000Z", начала анализа вредоносного ПО
// AnalysisEnded - время, в формате "2016-05-12T08:17:27.000Z", когда был завершен анализ вредоносного ПО
// ResultName - результат классификации или имя, присвоенное экземпляру вредоносного ПО инструментом анализа (сканером)
// Result - один, из заранее определенного (предложенного) перечня результатов классификации, определяется аналитическим инструментом или сканером
// AnalysisScoRefs - список идентификаторов на другие наблюдаемые Domain Objects STIX которые были захвачены в процессе наблюдения
// SampleRef - содержит ссылку на файл, сетевой трафик или объект на основе которого был выполнен анализ вредоносного ПО
// AvResult - результат аналитической обработки (ЭТО ПОЛЕ ЕСТЬ ТОЛЬКО В ПРИМЕРЕ, в описании типа данного поля нет)
type MalwareAnalysisDomainObjectsSTIX struct {
	CommonPropertiesObjectSTIX
	CommonPropertiesDomainObjectSTIX
	Product                   string               `json:"product" bson:"product" required:"true"`
	Version                   string               `json:"version" bson:"version"`
	HostVMRef                 IdentifierTypeSTIX   `json:"host_vm_ref" bson:"host_vm_ref"`
	OperatingSystemRef        IdentifierTypeSTIX   `json:"operating_system_ref" bson:"operating_system_ref"`
	InstalledSoftwareRefs     []IdentifierTypeSTIX `json:"installed_software_refs" bson:"installed_software_refs"`
	ConfigurationVersion      string               `json:"configuration_version" bson:"configuration_version"`
	Modules                   []string             `json:"modules" bson:"modules"`
	AnalysisEngineVersion     string               `json:"analysis_engine_version" bson:"analysis_engine_version"`
	AnalysisDefinitionVersion string               `json:"analysis_definition_version" bson:"analysis_definition_version"`
	Submitted                 time.Time            `json:"submitted" bson:"submitted"`
	AnalysisStarted           time.Time            `json:"analysis_started" bson:"analysis_started"`
	AnalysisEnded             time.Time            `json:"analysis_ended" bson:"analysis_ended"`
	ResultName                string               `json:"result_name" bson:"result_name"`
	Result                    OpenVocabTypeSTIX    `json:"result" bson:"result"`
	AnalysisScoRefs           []IdentifierTypeSTIX `json:"analysis_sco_refs" bson:"analysis_sco_refs"`
	SampleRef                 IdentifierTypeSTIX   `json:"sample_ref" bson:"sample_ref"`
}
 */